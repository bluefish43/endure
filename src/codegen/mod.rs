/*!

# The `codegen module`

Functions and structs to make the code generation
compilation phase - which takes HIR and outputs
LLVM bitcode, LLVM IR, binary, object files and
others, possible.

Essentially, here we take the High Level Intermediate Language
generated by the elements in the `check` module (see [`crate::check`])
and generate things from it.

Note that this module does not perform any sanitization or changes
to the High Level Intermediate Language generated by the semantical
check phase, and only generates based on what it's given.

 */

// start

use std::{
    cell::RefCell,
    collections::HashMap,
    fs::File,
    io::{self, Write},
    ops::Add,
    path::Path,
};

use derive_getters::Getters;
use inkwell::{
    attributes::{Attribute, AttributeLoc}, basic_block::BasicBlock, builder::Builder, context::{AsContextRef, Context}, data_layout::DataLayout, llvm_sys::{core::{LLVMAddAttributeAtIndex, LLVMCreateEnumAttribute, LLVMCreateTypeAttribute, LLVMGetEnumAttributeValue}, target::LLVMStoreSizeOfType, target_machine::LLVMGetHostCPUFeatures}, module::{Linkage, Module}, targets::{
        CodeModel, FileType, InitializationConfig, RelocMode, Target, TargetData, TargetMachine, TargetTriple
    }, types::{AnyType, AnyTypeEnum, ArrayType, AsTypeRef, BasicMetadataTypeEnum, BasicType, BasicTypeEnum, FunctionType}, values::{AnyValue, AnyValueEnum, BasicValue, BasicValueEnum, FunctionValue, IntValue, PointerValue}, AddressSpace, FloatPredicate, IntPredicate, OptimizationLevel
};

use crate::{
    ast::{
        expr::{BinaryOp, Conditional, LiteralExpr},
        typing::{PrimType, TypeBits}, Loc,
    },
    check::hir::{
        expr::{BinOpType, HIRAsReferenceExpr, HIRAssignmentExpr, HIRBinaryExpr, HIRCallExpr, HIRConditional, HIRExpr, HIRLiteralExpr, HIRReturnExpr, HIRWhileLoop}, matcher::{HIRCase, HIRPattern, HIRSwitch}, typing::HIRType, HIRBlock, HIRDecl, HIRFunctionDecl, HIRPrototype
    },
};

use self::llvm::Holder;

mod llvm;

macro_rules! float_compare {
    ($self:expr, $pred:ident, $lhs:expr, $rhs:expr) => {
        $self.builder()
            .build_float_compare(
                FloatPredicate::$pred,
                $lhs.into_float_value(),
                $rhs.into_float_value(),
                ""
            )
            .unwrap()
    }
}

macro_rules! int_compare {
    ($self:expr, $pred:ident, $lhs:expr, $rhs:expr) => {
        $self.builder()
            .build_int_compare(
                IntPredicate::$pred,
                $lhs.into_int_value(),
                $rhs.into_int_value(),
                ""
            )
            .unwrap()
    }
}

macro_rules! emmit_comparison_helper {
    ($name:ident, $sint_pred:ident, $uint_pred:ident, $float_pred:ident) => {
        /// Checks for (the predicate being compared to) between two types.
        fn $name(&'c self, ty: &HIRType, lhs: BasicValueEnum<'c>, rhs: BasicValueEnum<'c>) -> IntValue<'c> {
            use HIRType as T;
            // this is different for different types
            match ty {
                T::Primitive { loc: _, ty } => match ty {
                    PrimType::Int(_) => {
                        int_compare!(
                            self,
                            $sint_pred,
                            lhs,
                            rhs
                        )
                    }
                    PrimType::UInt(_)
                    | PrimType::Bool => {
                        int_compare!(
                            self,
                            $uint_pred,
                            lhs,
                            rhs
                        )
                    }
                    PrimType::Float(_) => {
                        float_compare!(
                            self,
                            $float_pred,
                            lhs,
                            rhs
                        )
                    }
                }
                T::Pointer { .. } => {
                    // convert them to integers and compare them
                    let left = self
                        .builder()
                        .build_ptr_to_int(lhs.into_pointer_value(), self.context().i64_type(), "")
                        .unwrap()
                        .as_basic_value_enum();
                    let right = self
                        .builder()
                        .build_ptr_to_int(lhs.into_pointer_value(), self.context().i64_type(), "")
                        .unwrap()
                        .as_basic_value_enum();
                    // we compare it as if it was an integer
                    int_compare!(
                        self,
                        $uint_pred,
                        left,
                        right
                    )
                }
                _ => unreachable!("Type is not supported by comparison operator")
            }
        }
    }
}

#[repr(u32)]
/// All of the current LLVM attributes.
pub enum AttributeKind {
    None = 0,
    AllocAlign,
    AllocatedPointer,
    AlwaysInline,
    Builtin,
    Cold,
    Convergent,
    CoroDestroyOnlyWhenComplete,
    DeadOnUnwind,
    DisableSanitizerInstrumentation,
    FnRetThunkExtern,
    Hot,
    ImmArg,
    InReg,
    InlineHint,
    JumpTable,
    MinSize,
    MustProgress,
    Naked,
    Nest,
    NoAlias,
    NoBuiltin,
    NoCallback,
    NoCapture,
    NoCfCheck,
    NoDuplicate,
    NoFree,
    NoImplicitFloat,
    NoInline,
    NoMerge,
    NoProfile,
    NoRecurse,
    NoRedZone,
    NoReturn,
    NoSanitizeBounds,
    NoSanitizeCoverage,
    NoSync,
    NoUndef,
    NoUnwind,
    NonLazyBind,
    NonNull,
    NullPointerIsValid,
    OptForFuzzing,
    OptimizeForDebugging,
    OptimizeForSize,
    OptimizeNone,
    PresplitCoroutine,
    ReadNone,
    ReadOnly,
    Returned,
    ReturnsTwice,
    SExt,
    SafeStack,
    SanitizeAddress,
    SanitizeHWAddress,
    SanitizeMemTag,
    SanitizeMemory,
    SanitizeThread,
    ShadowCallStack,
    SkipProfile,
    Speculatable,
    SpeculativeLoadHardening,
    StackProtect,
    StackProtectReq,
    StackProtectStrong,
    StrictFP,
    SwiftAsync,
    SwiftError,
    SwiftSelf,
    WillReturn,
    Writable,
    WriteOnly,
    ZExt,
    ByRef,
    ByVal,
    ElementType,
    InAlloca,
    Preallocated,
    StructRet,
    Alignment,
    AllocKind,
    AllocSize,
    Dereferenceable,
    DereferenceableOrNull,
    Memory,
    NoFPClass,
    StackAlignment,
    UWTable,
    VScaleRange,
    LastIntAttr,
}

#[repr(u32)]
/// All of the current LLVM calling conventions.
pub enum CallingConvention {
    C = 0,
    Fast = 8,
    Cold = 9,
    GHC = 10,
    HiPE = 11,
    AnyReg = 13,
    PreserveMost = 14,
    PreserveAll = 15,
    Swift = 16,
    CxxFastTLS = 17,
    Tail = 18,
    CFGuardCheck = 19,
    SwiftTail = 20,
    PreserveNone = 21,
    
    // first targeted cc
    X86StdCall = 64,
    X86FastCall = 65,
    ARMAPCS = 66,
    ArmAapcs = 67,
    ArmAapcsVfp = 68,
    Msp430Intr = 69,
    X86ThisCall = 70,
    PTXKernel = 71,
    PTXDevice = 72,
    SPIRFUNC = 75,
    SPIRKERNEL = 76,
    IntelOCLBI = 77,
    X64SysV = 78,
    Win64 = 79,
    X86VectorCall = 80,
    DummyHhvm = 81,
    DummyHhvmC = 82,
    X86Intr = 83,
    AVRIntr = 84,
    AVRSignal = 85,
    AVRBuiltin = 86,
    AMDGpuVs = 87,
    AMDGpuGs = 88,
    AMDGpuPs = 89,
    AMDGpuCs = 90,
    AMDGpuKernel = 91,
    X86RegCall = 92,
    AMDGpuHs = 93,
    MSP430Builtin = 94,
    AMDGPULs = 95,
    AMDGPUEs = 96,
    AArch64VectorCall = 97,
    AArch64SVEVectorCall = 98,
    WASMEmscriptenInvoke = 99,
    AMDGPUGfx = 100,
    M68kINTR = 101,
    AArch64SMEABISupportRoutinesPreserveMostFromX0 = 102,
    AArch64SMEABISupportRoutinesPreserveMostFromX2 = 103,
    AMDGPUCSChain = 104,
    AMDGPUCSChainPreserve = 105,
    M68kRTD = 106,
    GRAAL = 107,
    ARM64ECThunkX64 = 108,
    ARM64ECThunkNative = 109,
    RISCVVectorCall = 110,
    MaxID = 1023
}

/// A file format to export the file as.
pub enum ExportFormat {
    // -- llvm specific formats
    /// LLVM IR
    LLVMIR,

    /// LLVM Bitcode
    LLVMBitCode,

    /// An object file.
    Object,

    /// Endure's HIR representation.
    HIR,

    /// Text assembly.
    Assembly,
}

/// The center of code generation.
pub struct Emmitter<'c> {
    /// What holds all of LLVM's essentials.
    holder: Holder<'c>,
    /// The current scope's variables.
    scopes: RefCell<Vec<Scope<'c>>>,
    /// The exporting options we're using.
    options: ExportOptions,
}

#[derive(Default)]
/// A scope in the `Emitter`.
pub struct Scope<'c> {
    /// The variables declared at this scope.
    variables: HashMap<String, AnyValueEnum<'c>>,
    /// The deferred expressions at this scope and
    /// if they were already executed or not.
    deferred: Vec<(HIRExpr, bool)>,
    /// If this is a function.
    is_function: bool,
    /// If this is not a loop or within a
    /// conditional without an else clause.
    go_beyond_one_scope: bool,
}

#[derive(Getters)]
/// Options to use when exporting.
pub struct ExportOptions {
    /// The file format to export.
    pub format: ExportFormat,
    /// The output file name to use.
    pub output: String,
    /// The optimization level to apply.
    pub optimization_level: OptimizationLevel,
    /// If we are using position-independent
    /// code generation.
    pub use_pie: bool,
    /// The model of code to use.
    /// 
    /// This can be JIT, small, medium,
    /// kernel and others.
    pub code_model: CodeModel,
    /// A specified target triple.
    pub triple: Option<String>,
    /// The optimization options we're enabling
    /// (or disabling)
    pub opts: OptimizationOptions,
}

impl<'c> Emmitter<'c> {
    /// Constructs an `Emitter`.
    pub fn new(context: &'c Context, module_name: &str, opts: ExportOptions) -> Self {
        Self {
            holder: Holder::from_context(context, module_name),
            scopes: RefCell::default(),
            options: opts,
        }
    }

    pub fn dump(&'c self) {
        self.module().print_to_stderr();
    }

    /// Exports the emitted LLVM IR to a file with the
    /// specified file format.
    pub fn export(
        &'c self
    ) -> Result<(), io::Error> {
        self.module().print_to_stderr();
        self.module().verify().unwrap();

        let mut file = File::create(self.options.output())?;

        match self.options.format() {
            ExportFormat::LLVMIR => {
                // write the llvm ir to the file
                write!(file, "{}", self.module().print_to_string().to_string())?;
            }
            ExportFormat::LLVMBitCode => {
                // write the llvm bitcode to the file
                file.write_all(self.module().write_bitcode_to_memory().as_slice())?;
            }
            ExportFormat::Object
            | ExportFormat::Assembly => {
                // initialize target
                Target::initialize_native(&InitializationConfig::default()).map_err(|_| {
                    io::Error::other(
                        "Failed to initialize native target".to_string()
                    )
                })?;
                let relocation_mode = if *self.options.use_pie() {
                    RelocMode::PIC
                } else {
                    RelocMode::Default
                };
                let code_model = *self.options.code_model();
                let out_path = Path::new(self.options.output().as_str());
                let triple = match self.options.triple() {
                    Some(triple) => {
                        TargetTriple::create(triple)
                    }
                    None => {
                        TargetMachine::get_default_triple()
                    }
                };
                let target = Target::from_triple(&triple)
                    .map_err(
                        |err| {
                            io::Error::other(
                                err.to_string()
                            )
                        }
                    )?;
                let cpu = TargetMachine::get_host_cpu_name().to_string();
                let features = TargetMachine::get_host_cpu_features().to_string();
                let target_machine = target
                    .create_target_machine(
                        &triple,
                        &cpu,
                        &features,
                        self.options.optimization_level,
                        relocation_mode,
                        code_model
                    ).ok_or(
                        io::Error::other(
                            "Failed to get target machine".to_string()
                        )
                    )?;

                target_machine
                    .write_to_file(
                        self.module(),
                        if let ExportFormat::Object = self.options.format {
                            FileType::Object
                        } else {
                            FileType::Assembly
                        },
                        out_path
                    )
                    .map_err(|err| {
                        io::Error::other(err.to_string())
                    })?;
            }
            ExportFormat::HIR => unimplemented!(),
        }

        Ok(())
    }

    /// Emmits machine code for a program.
    pub fn emmit_program(&'c self, decls: &[HIRDecl]) {
        for decl in decls.iter() {
            self.emmit_decl(decl)
        }
    }

    /// Emmits machine code for a declaration in High Level IR.
    fn emmit_decl(&'c self, decl: &HIRDecl) {
        match decl {
            HIRDecl::FunctionDecl(hir_function_decl) => self.emmit_func_decl(hir_function_decl),
        }
    }

    /// Emits machine code for an HIR function declaration.
    fn emmit_func_decl(&'c self, decl: &HIRFunctionDecl) {
        let (function_type, param_attrs) = self.func_type_of_proto(&decl.prototype);

        let function_value = self.get_or_define(decl.prototype.name(), function_type);

        // add parameter attributes
        for (param_idx, param_attr) in param_attrs {
            function_value.add_attribute(
                AttributeLoc::Param(param_idx as u32),
                param_attr,
            )
        }
        
        let block = self.context().append_basic_block(function_value, "start");
        self.builder().position_at_end(block);

        self.push_scope(true, false);

        for decl in decl.block.stmts().iter() {
            self.emmit_expr(decl,);
        }

        self.if_not_finished(|builder| {
            builder
                .build_unreachable()
                .unwrap();
        });

        self.pop_scope();
    }

    /// Emmits all of the expressions contained in a block.
    fn emmit_block(&'c self, block: &HIRBlock) {
        for expr in block.stmts().iter() {
            self.emmit_expr(expr);
        }
    }

    /// Gets or defines a function if not yet defined.
    fn get_or_define(&self, func: &str, ty: FunctionType<'c>) -> FunctionValue<'c> {
        match self.holder.module().get_function(func) {
            Some(func) => func,
            None => {
                let func = self
                    .holder
                    .module()
                    .add_function(func, ty, Some(Linkage::External));
                // func.set_call_conventions(CallingConvention::Fast as u32);
                func
            },
        }
    }

    /// Gets the function type of a prototype.
    fn func_type_of_proto(&'c self, proto: &HIRPrototype) -> (FunctionType<'c>, Vec<(usize, Attribute)>) {
        let mut args = vec![];
        let mut attrs = vec![];
        let mut add_index = 0;

        // if returns aggregate, use void and take
        // return parameter instead
        let return_type = if proto.return_type().is_aggr() {
            args.push(
                self.context()
                    .i32_type()
                    .ptr_type(AddressSpace::default())
                    .as_basic_type_enum()
                    .into()
            );
            attrs.push((0,
                self.attribute_for_kind(AttributeKind::WriteOnly)
            ));
            attrs.push((0,
                self.attribute_for_kind(AttributeKind::NoUndef)
            ));
            attrs.push((0,
                self.attribute_for_kind(AttributeKind::NoCapture)
            ));
            add_index += 1;

            self.context()
                .i32_type()
                .into()
        } else {
            let (value, _) = self.llvm_type_argument(&proto.return_type(), true);
            value
        };

        for (idx, arg) in proto.arguments().iter().enumerate() {
            let (arg_ty, arg_attr) = self.llvm_type_argument(&arg.ty, false);
            args.push(basic_type(arg_ty).into());
            for attr in arg_attr {
                attrs.push(
                    (idx + add_index,
                    attr)
                )
            }
        }

        (
            basic_type(return_type).fn_type(args.as_slice(), false),
            attrs
        )
    }

    /// Gets a type in LLVM for its representation in HIR.
    fn llvm_type(&'c self, ty: &HIRType) -> AnyTypeEnum<'c> {
        use HIRType as HT;
        use PrimType as PT;
        use TypeBits as TB;

        match ty {
            HT::Primitive { loc, ty } => match ty {
                PT::Bool => self.holder.context().bool_type().into(),
                PT::Float(bits) => match bits {
                    TB::B32 => self.holder.context().f32_type(),
                    TB::B64 => self.holder.context().f64_type(),
                    _ => unreachable!(),
                }
                .into(),
                PT::Int(bits) | PT::UInt(bits) => match bits {
                    TB::B8 => self.holder.context().i8_type(),
                    TB::B16 => self.holder.context().i16_type(),
                    TB::B32 => self.holder.context().i32_type(),
                    TB::B64 => self.holder.context().i64_type(),
                }
                .into(),
            },
            HT::SizedArray { size, element_type } => {
                BasicTypeEnum::try_from(self.llvm_type(&element_type))
                    .unwrap()
                    .array_type(size.1 as u32)
                    .as_any_type_enum()
            }
            HT::Struct(_) => {
                unreachable!("Error: unaligned struct type reached the code generation phase")
            }
            HT::AlignedStruct(fields) => {
                self.context()
                    .struct_type(
                        fields.iter()
                            .map(|ty| {
                                basic_type(self.llvm_type(&ty.0))
                            })
                            .collect::<Vec<_>>()
                            .as_slice(),
                        false
                    )
                    .as_any_type_enum()
            }
            HT::SumType { discriminant, variants: _ } => {
                // get the type of the discriminant
                let discriminant = basic_type(self.llvm_type(&discriminant));
                // get the union of its contents
                let size_of_self = ty.size(false);
                // return opaque type
                let inner_union = self.context()
                    .i8_type()
                    .array_type(size_of_self as u32)
                    .as_basic_type_enum();
                // return a struct of the sum
                self.context()
                    .struct_type(
                        &[
                            discriminant,
                            inner_union
                        ],
                        false
                    )
                    .as_any_type_enum()
            }
            HT::Union(_) => {
                let size_of_self = ty.size(true);
                // return opaque type
                self.context()
                    .i8_type()
                    .array_type(size_of_self as u32)
                    .as_any_type_enum()
            }
            HT::Pointer { pointee, mutability: _ } => BasicTypeEnum::try_from(self.llvm_type(&pointee))
                .unwrap()
                .ptr_type(AddressSpace::default())
                .as_any_type_enum(),
            HT::FunctionPointer(proto) => self.func_type_of_proto(proto).0.as_any_type_enum(),
            HT::Void => self.holder.context().void_type().as_any_type_enum(),
            HT::Universe => unreachable!("Universe type here is an error in type checker"),
        }
    }

    /// Gets a type in LLVM for its representation in HIR
    /// for a function argument.
    fn llvm_type_argument(&'c self, ty: &HIRType, is_return_type: bool) -> (AnyTypeEnum<'c>, Vec<Attribute>) {
        use HIRType as HT;

        match ty {
            HT::Struct(fields) => {
                unreachable!("Error: unaligned struct type reached the code generation phase")
            }
            HT::AlignedStruct(fields) => {
                if is_return_type {
                    (self.context().i32_type().as_any_type_enum(), vec!())
                } else {
                    // create struct type
                    let struct_type = self.context()
                        .struct_type(
                            fields.iter()
                                .map(|ty| {
                                    basic_type(self.llvm_type(&ty.0))
                                })
                                .collect::<Vec<_>>()
                                .as_slice(),
                            false
                        );
                    // create byval(Struct) attribute
                    let by_val_attribute = self.attribute_for_type(
                        AttributeKind::ByVal,
                        struct_type.into()
                    );

                    (struct_type.ptr_type(AddressSpace::default()).as_any_type_enum(), vec!(by_val_attribute))
                }
            }
            HT::Pointer { pointee, mutability } => {
                let pointee = basic_type(self.llvm_type(&pointee));
                let pointer_type = pointee.ptr_type(AddressSpace::default());
                // if it is immutable add readonly attribute
                let attributes = if mutability.is_none() {
                    vec!(self.attribute_for_kind(AttributeKind::ReadOnly), self.attribute_for_kind(AttributeKind::Dereferenceable))
                } else {
                    vec!(self.attribute_for_kind(AttributeKind::Writable))
                };
                (pointer_type.as_any_type_enum(), attributes)
            }
            _ => (self.llvm_type(ty), vec!()),
        }
    }

    /// Pushes a new scope to the stack of scopes.
    fn push_scope(&self, is_function: bool, go_beyond_one_scope: bool) {
        self.scopes.borrow_mut().push(Scope {
            is_function,
            go_beyond_one_scope,
            ..Default::default()
        });
    }

    /// Adds a new deferred expression to the scope.
    fn add_deferred_expr(&self, expr: HIRExpr) {
        // add a new deferred
        // we put false here because it hasn't been
        // executed yet
        self.scopes
            .borrow_mut()
            .last_mut()
            .unwrap()
            .deferred
            .push((expr, false))
    }

    /// Pops a scope, executing all of the deferred
    /// expressions declared in reverse order of
    /// declaration.
    fn pop_scope(&'c self) {
        let mut binding = self.scopes.borrow_mut();
        let last_scope = binding
            .last_mut()
            .unwrap();

        // go through deferred of last scope
        while let Some((deferred, was_executed)) = last_scope.deferred.pop() {
            // only do defer if wasn't already executed
            if !was_executed {
                self.emmit_expr(&deferred);
            }
        }

        binding.pop();
    }

    /// Does all defers for the variables declared until now
    /// within the current function.
    fn do_ret_defers(&'c self) {
        let mut binding = self.scopes.borrow_mut();
        let mut iterator = binding.iter_mut().rev().enumerate();

        let mut go_beyond_one_scope = true;

        // go through all scopes of this function
        while let Some((scope_index, scope)) = iterator.next() {
            // execute defer statements in this scope
            for (deferred, was_executed) in scope.deferred.iter_mut().rev() {
                if !*was_executed {
                    self.emmit_expr(deferred);
                    // go_beyond_one_scope is true for function declarations
                    // or conditions which have an else clause
                    //
                    // false for loops and conditionals w/o else clause
                    if (scope.go_beyond_one_scope && go_beyond_one_scope) || scope_index == 0 {
                        *was_executed = true;
                    } else {
                        go_beyond_one_scope = false;
                    }
                }
            }

            // check at end if this is function scope
            // and then end
            if scope.is_function {
                break;
            }
        }
    }

    /// Emmits machine code for the input expression.
    fn emmit_expr(&'c self, expr: &HIRExpr) -> AnyValueEnum<'c> {
        self.emmit_expr_impl(expr, false, None)
    }

    fn emmit_expr_impl(&'c self, expr: &HIRExpr, take_lvalue: bool, aggr_ptr: Option<PointerValue<'c>>) -> AnyValueEnum<'c> {
        use HIRExpr as HE;

        match expr {
            HE::AsReference(other) => self.emmit_expr_impl(&other.1, true, None),
            HE::Literal(lit) => self.emmit_lit(lit),
            HE::Binary(bin) => self.emmit_bin(bin),
            HE::Assignment(assignment) => {
                self.emmit_assignment(assignment);
                self.const_null()
            }
            HE::SlotDecl(to, ty) => {
                let ty = basic_type(self.llvm_type(ty));
                let mem = self.builder().build_alloca(ty, "slot").unwrap();
                self.set_var(to, mem.as_any_value_enum());
                mem.as_any_value_enum()
            }
            HE::Call(call_expr) => self.emmit_call(call_expr),
            HE::Variable(var, vty) => {
                if take_lvalue {
                    self.get_var(var.as_str())
                } else {
                    if vty.is_aggr() {
                        self.get_var(var.as_str())
                    } else {
                        self.builder()
                            .build_load(
                                basic_type(self.llvm_type(vty)),
                                self.get_var(var.as_str()).into_pointer_value(),
                                "loaded variable",
                            )
                            .unwrap()
                            .as_any_value_enum()
                    }
                }
            }
            HE::Switch(switch) => self.emmit_switch(switch),
            HE::AccessUnionProperty { union_expr, property_ty, must_dereference_first } => {
                // for accessing a property of a union, we simply
                // read from it the value we wish to treat it as
                let union_value = if *must_dereference_first {
                    self.builder()
                        .build_load(
                            self.context().i32_type().ptr_type(AddressSpace::default()),
                            self.emmit_expr_impl(&union_expr, true, None).into_pointer_value(),
                            "pointer to union"
                        )
                        .unwrap()
                        .as_any_value_enum()
                } else {
                    self.emmit_expr_impl(&union_expr, true, None)
                };
                self
                    .emmit_raw_union_access_property(
                        union_value.into_pointer_value(),
                        property_ty,
                        take_lvalue
                    )
                    .as_any_value_enum()
            }
            HE::AccessStructProperty { struct_expr, struct_ty, property_index, property_ty, must_dereference_first: must_dereference_struct } => {
                let struct_value = if *must_dereference_struct {
                    self.builder()
                        .build_load(
                            self.context().i32_type().ptr_type(AddressSpace::default()),
                            self.emmit_expr_impl(&struct_expr, false, None).into_pointer_value(),
                            "pointer to struct"
                        )
                        .unwrap()
                        .into_pointer_value()
                } else {
                    self.emmit_expr_impl(&struct_expr, true, None).into_pointer_value()
                };
                self
                    .emmit_raw_struct_access_property(
                        struct_value,
                        struct_ty,
                        *property_index,
                        property_ty,
                        take_lvalue
                    )
                    .as_any_value_enum()
            }
            HE::Argument { name, ty, index } => {
                if let Some(argument_val) = self.get_var_opt(name.as_str()) {
                    argument_val
                } else {
                    // get the type of param
                    let arg_type = basic_type(self.llvm_type(ty));
                    // get the function we're working on
                    let current_function = self.builder()
                        .get_insert_block()
                        .unwrap()
                        .get_parent()
                        .unwrap();

                    // get the argument
                    let argument = current_function
                        .get_nth_param(*index as u32)
                        .unwrap();

                    // check if it is aggregate (byval pointer)
                    if ty.is_aggr() {
                        argument.as_any_value_enum()
                    } else {
                        // create local binding
                        let local_argument = self.builder()
                        .build_alloca(arg_type, "argument")
                        .unwrap();

                        // store the value inside of the local binding
                        if !arg_type.is_struct_type() && !arg_type.is_array_type() {
                        // use store if regular type
                        self.builder()
                            .build_store(
                                local_argument, argument
                            )
                            .unwrap();
                        } else {
                        // otherwise use memcpy
                        self.builder()
                            .build_memcpy(
                                local_argument,
                                8,
                                argument.into_pointer_value(),
                                8,
                                arg_type.size_of().unwrap(),
                            )
                            .unwrap();
                        }
                        // set the argument's value locally
                        self.set_var(name.as_str(), local_argument.as_any_value_enum());
                        // return the allocated value for the argument
                        local_argument.as_any_value_enum()
                    }
                }
            }
            HE::GlobalFunc(name, proto) => {
                let (func_ty, func_attrs) = self.func_type_of_proto(proto);
                let func = self
                    .get_or_define(&name, func_ty);
                for (param_idx, param_attr) in func_attrs {
                    func.add_attribute(AttributeLoc::Param(param_idx as u32), param_attr)
                }
                func.as_any_value_enum()
            }
            HE::DefineAndEval(define, expr) => {
                let insert_point = self.builder()
                    .get_insert_block()
                    .unwrap();
                self.emmit_decl(define);
                self.builder()
                    .position_at_end(insert_point);
                self.emmit_expr(&expr)
            }
            HE::Sequence(se) => {
                let mut last = None;
                for expr in se {
                    last = Some(self.emmit_expr(expr));
                }
                last.expect("Empty sequence is not valid")
            }
            HE::Dereference(pointee, pointer) => {
                self.builder()
                    .build_load(
                        basic_type(self.llvm_type(pointee)),
                        self.emmit_expr(&pointer).into_pointer_value(),
                        "dereferenced pointer"
                    )
                    .unwrap()
                    .as_any_value_enum()
            }
            HE::InstantiateUnion(union_ty, field, is_field_aggr) => self.emmit_instantiate_union(union_ty, field, is_field_aggr.as_ref(), aggr_ptr),
            HE::InstantiateStruct(ty, fields) => self.emmit_instantiate_struct(ty, fields, aggr_ptr),
            HE::Return(ret_expr) => self.emmit_ret(ret_expr),
            HE::Conditional(cond) => self.emmit_cond(cond),
            HE::WhileLoop(loo) => self.emmit_while(loo),
            HE::Defer(deferred) => {
                self.add_deferred_expr((**deferred).clone());
                self.const_null()
            }
        }
    }

    /// Emmits a literal as machine code.
    fn emmit_lit(&'c self, lit: &HIRLiteralExpr) -> AnyValueEnum<'c> {
        match lit {
            HIRLiteralExpr::Int(t, i) => {
                self.llvm_type(t)
                    .into_int_type()
                    .const_int(i.2, matches!(t, HIRType::Primitive { ty: PrimType::Int(_), .. }))
            }
        }
        .as_any_value_enum()
    }

    /// Emits a binary expression.
    fn emmit_bin(&'c self, expr: &HIRBinaryExpr) -> AnyValueEnum<'c> {
        let lhs = basic_value(self.emmit_expr(&expr.left_hand_side));
        let rhs = basic_value(self.emmit_expr(&expr.right_hand_side));
        match expr.op.1 {
            BinaryOp::Plus => match expr.op_ty {
                BinOpType::Int | BinOpType::UInt => self
                    .builder()
                    .build_int_add(lhs.into_int_value(), rhs.into_int_value(), "binary_op_result")
                    .unwrap()
                    .into(),
                BinOpType::Float => self
                    .builder()
                    .build_float_add(lhs.into_float_value(), rhs.into_float_value(), "binary op result")
                    .unwrap()
                    .into(),
            },
        }
    }

    /// Emmits the instantiation of an union.
    fn emmit_instantiate_union(
        &'c self, hir_union_ty: &HIRType, 
        field: &HIRExpr, 
        is_field_aggr: Option<&HIRType>,
        aggr_ptr: Option<PointerValue<'c>>,
    ) -> AnyValueEnum<'c> {
        let uni_ty = basic_type(self.llvm_type(hir_union_ty));
        // allocate memory for the struct
        let uni_mem = if let Some(aggr_ptr) = aggr_ptr {
            aggr_ptr
        } else {
            self.builder()
                .build_alloca(uni_ty, "instantiated union")
                .unwrap()
        };
        // evaluate the field
        // set the index
        if is_field_aggr.is_some() {
            self.emmit_expr_impl(field, false, Some(uni_mem));
        } else {
            let field_value = basic_value(self.emmit_expr(field));
            self.builder()
                .build_store(
                    uni_mem,
                    field_value,
                )
                .unwrap();
        }
        uni_mem.as_any_value_enum()
    }

    /// Emits the instantiation of a struct.
    fn emmit_instantiate_struct(&'c self, hir_stct_ty: &HIRType, fields: &[(HIRExpr, Option<HIRType>)], aggr_ptr: Option<PointerValue<'c>>) -> AnyValueEnum<'c> {
        let stct_ty = basic_type(self.llvm_type(hir_stct_ty));
        let stct_mem = self.allocate_struct_memory(stct_ty, aggr_ptr);

        if let HIRType::AlignedStruct(aligned_fields) = hir_stct_ty {
            for (index, field) in fields.iter().enumerate() {
                // Calculate the actual memory index considering alignment and padding
                let actual_index = index_aligned(aligned_fields.iter(), index as u32);

                // Get the address for the field within the struct
                let field_address = self.get_struct_field_address(stct_ty, stct_mem, actual_index);

                // Assign the field value, handling aggregates in-place
                self.assign_field_value(field, field_address);
            }
            stct_mem.as_any_value_enum()
        } else {
            unreachable!("Instantiating non-aligned struct type: {:?}", hir_stct_ty)
        }
    }

    /// Allocates memory for the struct.
    fn allocate_struct_memory(
        &'c self,
        stct_ty: BasicTypeEnum<'c>,
        aggr_ptr: Option<PointerValue<'c>>
    ) -> PointerValue<'c> {
        aggr_ptr.unwrap_or_else(|| {
            self.builder()
                .build_alloca(stct_ty, "instantiated struct")
                .unwrap()
        })
    }

    /// Gets the address of a field within the struct.
    fn get_struct_field_address(&'c self, stct_ty: BasicTypeEnum<'c>, stct_mem: PointerValue<'c>, actual_index: u32) -> PointerValue<'c> {
        if actual_index == 0 {
            stct_mem
        } else {
            self.builder()
                .build_struct_gep(stct_ty, stct_mem, actual_index, "address of field")
                .unwrap()
        }
    }

    /// Assigns the value to the field, handling aggregates in-place.
    fn assign_field_value(&'c self, field: &(HIRExpr, Option<HIRType>), field_address: PointerValue<'c>) {
        let field_is_aggr = field.1.as_ref().map(|t| t.is_aggr()).unwrap_or_default();
        if field_is_aggr {
            // Instantiate aggregate field directly at the calculated address
            self.emmit_expr_impl(&field.0, false, Some(field_address));
        } else {
            // Evaluate and store the field value at the calculated address
            let field_value = basic_value(self.emmit_expr(&field.0));
            self.builder()
                .build_store(field_address, field_value)
                .unwrap();
        }
    }

    /// Emmits machine code for an assignment.
    fn emmit_assignment(&'c self, assignment: &HIRAssignmentExpr) {
        let lhs = basic_value(self.emmit_expr_impl(&assignment.0.left_hand_side, true, None));
        let value = basic_value(self.emmit_expr_impl(&assignment.0.right_hand_side, false, Some(lhs.into_pointer_value())));

        if !assignment.1.as_ref().map(|t| t.is_aggr()).unwrap_or(true) {
            self.emmit_raw_assignment(
                lhs,
                value,
                assignment.1.as_ref()
            );
        } else {
            self.builder()
                .build_store(
                    lhs.into_pointer_value(),
                    value
                )
                .unwrap();
        }
    }

    /// What does the ACTUAL assignment.
    fn emmit_raw_assignment(&'c self, lhs: BasicValueEnum<'c>, value: BasicValueEnum<'c>, aggr: Option<&HIRType>) {
        if let Some(aggr_ty) = aggr {
            // do memcpy if assigning to aggregate type
            // get size of type
            let size = self.context().i64_type().const_int(aggr_ty.size(true) as u64, false);
            // make memcpy
            self.builder()
                .build_memcpy(
                    lhs.into_pointer_value(),
                    8,
                    value.into_pointer_value(),
                    8,
                    size,
                )
                .unwrap();
        } else {
            // else don't
            self.builder()
                .build_store(lhs.into_pointer_value(), value)
                .unwrap();
        }
    }

    /// Emmits a call to a function.
    fn emmit_call(&'c self, call: &HIRCallExpr) -> AnyValueEnum<'c> {
        let callee = self.emmit_expr(&call.callee);
        let mut params = vec![];

        if let Some(aggr_ty) = call.returns_aggregate.as_ref() {
            let output = self.builder()
                .build_alloca(
                    basic_type(self.llvm_type(aggr_ty)),
                    "aggregate return value"
                )
                .unwrap();

            params.push(output.into());

            for param in call.params.iter() {
                params.push(basic_value(self.emmit_expr(param)).into());
            }
    
            self.builder()
                .build_call(callee.into_function_value(), &params, "call")
                .unwrap();

            output.into()
        } else {
            for param in call.params.iter() {
                params.push(basic_value(self.emmit_expr(param)).into());
            }
    
            self.builder()
                .build_call(callee.into_function_value(), &params, "call")
                .unwrap()
                .as_any_value_enum()
        }
    }

    /// Emmits a `switch` instruction.
    fn emmit_switch(&'c self, switch: &HIRSwitch) -> AnyValueEnum<'c> {
        // get current block
        let current_block = self.builder()
            .get_insert_block()
            .unwrap();
        // append end block
        let end_block = self.context()
            .append_basic_block(current_block.get_parent().unwrap(), "switch: end block");
        // set current block
        self.builder()
            .position_at_end(current_block);
        // evaluate what to match
        let matched_value = basic_value(self.emmit_expr_impl(&switch.value(), true, None));

        let mut all_obtained = vec![];
        // this is the block to jump to after a case
        let mut next: BasicBlock;
        // evaluate all cases
        for case in switch.patterns() {
            // emmit the case
            if let Some(unmatched) = self.emmit_case(case, matched_value, end_block) {
                all_obtained.push(unmatched);
                next = unmatched;
            } else {
                break;
            }
            // set position to the unmatched block
            self.builder()
                .position_at_end(next);
        }

        // remove any block which was not used
        for obtained in all_obtained {
            if obtained.get_first_instruction().is_none()
            && obtained.get_first_use().is_none() {
                obtained
                    .remove_from_function()
                    .unwrap();
            }
        }

        // remove end block if it is ot used
        if end_block.get_first_use().is_none() {
            end_block.remove_from_function().unwrap();
        }

        self.const_null()
    }

    /// Emmits a single `case` instruction.
    /// 
    /// The `value` basic value is what to match.
    /// The `end` basic block if the block after
    /// the `switch` statement.
    /// 
    /// Returns the basic block for if the pattern
    /// wasn't matched.
    fn emmit_case(&'c self, case: &HIRCase, value: BasicValueEnum<'c>, end: BasicBlock<'c>) -> Option<BasicBlock<'c>> {
        // push a new scope
        self.push_scope(false, false);
        // get the current block.
        let EmmittedPattern { matched, unmatched } = self.emmit_pattern(case.pattern(), value);

        // set the insert block
        self.builder()
            .position_at_end(matched);
        // emmit the block of the case
        self.emmit_block(case.block());
        // if current block is not terminated go to
        // end of match statement
        self.if_not_finished(|builder| {
            builder
                .build_unconditional_branch(end)
                .unwrap();
        });
        // pop the current scope
        self.pop_scope();

        // return the block to go to if this didn't match
        unmatched
    }

    /// Emmits a pattern and returns the block where code will execute if
    /// it is matched successfully. The `value` value is what to match with.
    fn emmit_pattern(&'c self, pattern: &HIRPattern, value: BasicValueEnum<'c>) -> EmmittedPattern {
        use HIRPattern as P;

        // current block
        let current_block = self.builder()
            .get_insert_block()
            .unwrap();
        // this is where to go if it matched
        let go_to_if_matched = self.context()
            .append_basic_block(current_block.get_parent().unwrap(), "pattern matched");

        if let P::WildCard { ty, is_aggregate, name } = pattern {
            // Here we have to put this name in scope
            // this is always going to match
            self.builder()
                .build_unconditional_branch(go_to_if_matched)
                .unwrap();
            // set to the block
            self.builder()
                .position_at_end(go_to_if_matched);
            // get the type for the allocation
            let allocating_ty = basic_type(self.llvm_type(ty));
            // allocate for the variable
            let allocated_space = self.builder()
                .build_alloca(allocating_ty, "wildcard pattern binding")
                .unwrap();
            // set variable
            self.set_var(name, allocated_space.as_any_value_enum());
            // store value
            self.emmit_raw_assignment(
                allocated_space.as_basic_value_enum(),
                if !is_aggregate {
                    self.builder()
                        .build_load(
                            allocating_ty,
                            value.into_pointer_value(),
                            ""
                        )
                        .unwrap()
                        .as_basic_value_enum()
                } else {
                    value
                },
                if *is_aggregate {
                    Some(ty)
                } else {
                    None
                }
            );
            EmmittedPattern {
                matched: go_to_if_matched,
                unmatched: None,
            }
        } else {
            // this is where to go if it didn't match
            let go_to_if_didnt_match = self.context()
                .append_basic_block(current_block.get_parent().unwrap(), "case not matched");

            match pattern {
                P::Literal(literal_ty, literal) => {
                    // check if is equal to literal
                    let literal = basic_value(self.emmit_lit(literal));
                    let loaded_value = self.builder()
                        .build_load(
                            basic_type(self.llvm_type(literal_ty)),
                            value.into_pointer_value(),
                            ""
                        ).unwrap();
                    let jump = self.emmit_eq(literal_ty, loaded_value, literal);
                    // build conditional jump
                    self.builder()
                        .build_conditional_branch(
                            jump,
                            go_to_if_matched,
                            go_to_if_didnt_match
                        )
                        .unwrap();
                }
                P::Range { value_ty, begin, end } => {
                    let loaded_value = self.builder()
                        .build_load(
                            basic_type(self.llvm_type(value_ty)),
                            value.into_pointer_value(),
                            ""
                        ).unwrap();
                    // get start and end literals
                    let start = basic_value(self.emmit_lit(begin));
                    let end = basic_value(self.emmit_lit(end));
                    // check if it is between bounds
                    let ge_to_start = self.emmit_ge(value_ty, loaded_value, start);
                    let le_to_end = self.emmit_le(value_ty, loaded_value, end);
                    // do an and
                    let is_within_bounds = self.builder()
                        .build_and(ge_to_start, le_to_end, "is_within_range_bounds")
                        .unwrap();
                    // build conditional jump
                    self.builder()
                        .build_conditional_branch(
                            is_within_bounds,
                            go_to_if_matched,
                            go_to_if_didnt_match
                        )
                        .unwrap();
                }
                P::DeStructure { structure, fields, is_union } => {
                    if *is_union {
                        // handling for unions
                        let (_, _, field_pattern, field_ty) = fields.first().unwrap();
                        // access the property inside the union
                        let field_value = self.emmit_raw_union_access_property(
                            value.into_pointer_value(),
                            field_ty,
                            false
                        );
                        // emmit the field
                        let field_emmitted = self.emmit_pattern(
                            field_pattern,
                            field_value,
                        );
                        if let Some(unmatched) = field_emmitted.unmatched {
                            // make the unmatched path of the subpath go to ours not matched
                            self.builder()
                                .position_at_end(unmatched);
                            self.builder()
                                .build_unconditional_branch(go_to_if_didnt_match)
                                .unwrap();
                        }
                        // go to ours if did match
                        self.builder()
                            .position_at_end(field_emmitted.matched);
                        self.builder()
                            .build_unconditional_branch(go_to_if_matched)
                            .unwrap();
                    } else {
                        // handling for structs
                        // this one's a bit more complex
                        let mut matched_next = None;
                        let mut field_iter = fields.iter().peekable();
                        while let Some((_, field_index, field_pattern, field_ty)) = field_iter.next() {
                            // access the property inside the struct
                            let field_value = self.emmit_raw_struct_access_property(
                                value.into_pointer_value(),
                                structure,
                                *field_index as u32,
                                field_ty,
                                false
                            );
                            // emmit the field
                            let field_emmitted = self.emmit_pattern(
                                field_pattern,
                                field_value,
                            );
                            if let Some(unmatched) = field_emmitted.unmatched {
                                // make the unmatched path of the subpath go to ours not matched
                                self.builder()
                                    .position_at_end(unmatched);
                                self.builder()
                                    .build_unconditional_branch(go_to_if_didnt_match)
                                    .unwrap();
                            }
                            if field_iter.len() == 1 {
                                // go to ours if did match
                                // and is last field matched
                                self.builder()
                                    .position_at_end(field_emmitted.matched);
                                self.builder()
                                    .build_unconditional_branch(go_to_if_matched)
                                    .unwrap();
                            } else {
                                // if is not last create new basic block
                                // and go there to continue checking for
                                // other fields
                                matched_next = Some(
                                    self.context()
                                        .append_basic_block(matched_next.unwrap_or(go_to_if_matched).get_parent().unwrap(), "next field basic block")
                                );
                            }
                        }
                    }
                }
                P::WildCard { .. } => unreachable!(),
            }
            EmmittedPattern {
                matched: go_to_if_matched,
                unmatched: Some(go_to_if_didnt_match),
            }
        }
    }
    
    // emmit the comparisons
    emmit_comparison_helper!(emmit_eq, EQ, EQ, OEQ);
    emmit_comparison_helper!(emmit_ne, NE, NE, ONE);
    emmit_comparison_helper!(emmit_lt, SLT, ULT, OLT);
    emmit_comparison_helper!(emmit_le, SLE, ULE, OLE);
    emmit_comparison_helper!(emmit_gt, SGT, UGT, OGT);
    emmit_comparison_helper!(emmit_ge, SGE, UGE, OGE);

    fn emmit_raw_struct_access_property(
        &'c self,
        struct_value: PointerValue<'c>,
        struct_ty: &HIRType,
        mut property_index: u32,
        property_ty: &HIRType,
        take_lvalue: bool,
    )  -> BasicValueEnum<'c> {
        if let HIRType::AlignedStruct(struct_ty) = struct_ty {
            property_index = index_aligned(
                struct_ty.iter(),
                property_index,
            );
        } else {
            panic!("Unaligned struct type found when accessing a property of a struct")
        }
        let struct_type = self.llvm_type(struct_ty);
        let property_type = self.llvm_type(property_ty);

        // if the property index is zero, we can
        // just use the pointer directly
        let address = if property_index == 0 {
            struct_value
        } else {
            self.builder()
                .build_struct_gep(
                    basic_type(struct_type),
                    struct_value,
                    property_index,
                    "address of field"
                )
                .unwrap()
        };

        if take_lvalue {
            address.as_basic_value_enum()
        } else {
            if property_ty.is_aggr() {
                let memory = self.builder()
                    .build_alloca(
                        basic_type(self.llvm_type(property_ty)),
                        "aggregate struct field load"
                    )
                    .unwrap();
                self.builder()
                    .build_memcpy(
                        memory,
                        8,
                        address,
                        8,
                        self.context()
                            .i64_type()
                            .const_int(property_ty.size(true) as u64, false)
                    )
                    .unwrap();
                memory.as_basic_value_enum()
            } else {
                self.builder()
                    .build_load(
                        basic_type(property_type),
                        address,
                        "struct field load"
                    )
                    .unwrap()
                    .as_basic_value_enum()
            }
        }
    }

    fn emmit_raw_union_access_property(
        &'c self,
        union_value: PointerValue<'c>,
        property_ty: &HIRType,
        take_lvalue: bool
    ) -> BasicValueEnum<'c> {
        let property_type = self.llvm_type(property_ty);

        if take_lvalue {
            union_value.as_basic_value_enum()
        } else {
            if property_ty.is_aggr() {
                let memory = self.builder()
                    .build_alloca(
                        basic_type(self.llvm_type(property_ty)),
                        "aggregate union field load"
                    )
                    .unwrap();
                self.builder()
                    .build_memcpy(
                        memory,
                        8,
                        union_value,
                        8,
                        self.context()
                            .i64_type()
                            .const_int(property_ty.size(true) as u64, false)
                    )
                    .unwrap();
                memory.as_basic_value_enum()
            } else {
                self.builder()
                    .build_load(
                        basic_type(property_type),
                        union_value,
                        "union field load"
                    )
                    .unwrap()
                    .as_basic_value_enum()
            }
        }
    }

    /// Emmits a return instruction.
    fn emmit_ret(&'c self, expr: &HIRReturnExpr) -> AnyValueEnum<'c> {
        if let Some(aggr_ty) = &expr.aggregate {
            // aggregate return
            let value = if let Some(val) = &expr.expr {
                basic_value(self.emmit_expr_impl(&val, true, None))
            } else {
                unreachable!()
            };
            // get size of type
            let size = self.llvm_type(&aggr_ty)
                .size_of()
                .unwrap();
            // make memcpy
            self.builder()
                .build_memcpy(
                    self.builder()  
                        .get_insert_block()
                        .unwrap()
                        .get_parent()
                        .unwrap()
                        .get_nth_param(0)
                        .unwrap()
                        .into_pointer_value(),
                    8,
                    value.into_pointer_value(),
                    8,
                    size,
                )
                .unwrap();

            

            self.builder()
                .build_return(Some(
                    &self.context().i32_type().const_int(0, false).as_basic_value_enum() as &dyn BasicValue<'c>
                ))
                .unwrap();
            self.const_null()
        } else {
            // normal return
            let value: Option<Box<dyn BasicValue>> = if let Some(val) = &expr.expr {
                Some(Box::new(basic_value(self.emmit_expr(&val))))
            } else {
                None
            };
            self.builder()
                .build_return(value.as_ref().map(|v| v.as_ref()))
                .unwrap();
            self.const_null()
        }
    }

    /// Emmits a literal as machine code.
    fn emmit_cond(&'c self, cond: &HIRConditional) -> AnyValueEnum<'c> {
        // do first things
        let condition = self
            .emmit_expr(&cond.condition)
            .into_int_value();
        let condition_block = self.builder()
            .get_insert_block()
            .unwrap();
        let current_function = condition_block
            .get_parent()
            .unwrap();
        let true_block = self.context()
            .append_basic_block(
                current_function,
                "cond true"
            );
        let false_or_end_block = self.context()
            .append_basic_block(
                current_function,
                "cond false"
            );

        // generate branch
        self.builder()
            .build_conditional_branch(
                condition,
                true_block,
                false_or_end_block
            )
            .unwrap();

        // build true block
        {
            // set insert block
            self.builder()
                .position_at_end(true_block);

            self.push_scope(false, cond.else_part.is_some());

            for expr in cond.then.stmts() {
                self.emmit_expr(expr);
            }

            // jump to end if not finished
            self.if_not_finished(
                |builder| {
                    builder
                        .build_unconditional_branch(
                            false_or_end_block
                        )
                        .unwrap();
                }
            );

            self.pop_scope();
        }

        // build false block - or not
        if let Some(false_block) = cond.else_part
            .as_ref()
            .map(|tuple| &tuple.1) {
                // generate new end block
                let end_block = self.context()
                    .append_basic_block(
                        current_function,
                        "cond end"
                    );
                // set insert block
                self.builder()
                    .position_at_end(false_or_end_block);

                self.push_scope(false, true);

                for expr in false_block.stmts() {
                    self.emmit_expr(expr);
                }

                // jump to end if not finished
                self.if_not_finished(
                    |builder| {
                        builder
                            .build_unconditional_branch(end_block)
                            .unwrap();
                    }
                );
                    
                self.builder()
                    .position_at_end(end_block);
    
                self.pop_scope();
            }

        self.const_null()
    }

    
    /// Emmits a literal as machine code.
    fn emmit_while(&'c self, cond: &HIRWhileLoop) -> AnyValueEnum<'c> {
        // get current function
        let current_block = self.builder()
            .get_insert_block()
            .unwrap();
        let current_function = current_block
            .get_parent()
            .unwrap();
        // get blocks
        let condition_block = self.context()
            .append_basic_block(current_function, "while condition");

        let body_block = self.context()
            .append_basic_block(current_function, "while block");

        let after_block = self.context()
            .append_basic_block(current_function, " while after");

        // build condition
        self.builder()
            .position_at_end(condition_block);
        let condition = self
            .emmit_expr(&cond.condition)
            .into_int_value();
        
        // build branch
        self.builder()
            .build_conditional_branch(
                condition,
                body_block,
                after_block
            )
            .unwrap();

        // build block
        {
            // set insert block
            self.builder()
                .position_at_end(body_block);

            self.push_scope(false, false);

            for expr in cond.block.stmts() {
                self.emmit_expr(expr);
            }

            self.pop_scope();
        }

        self.const_null()
    }

    /// Applies the predicate to the last basic block if it was not
    /// already finished (with a terminator instruction).
    fn if_not_finished<F>(&'c self, predicate: F) -> Option<()>
    where
        F: FnOnce(&Builder<'c>) -> (),
    {
        let block = self.builder()
            .get_insert_block()?;

        if block.get_terminator().is_none() {
            predicate(self.builder());
        }

        Some(())
    }

    /// Builds a const null pointer.
    fn const_null(&'c self) -> AnyValueEnum<'c> {
        self.builder()
            .build_int_to_ptr(
                self.context().i8_type().const_int(0, false),
                self.context().i8_type().ptr_type(AddressSpace::default()),
                "const null",
            )
            .unwrap()
            .into()
    }

    /// Sets a variable in the current scope.
    fn set_var(&'c self, s: &str, val: AnyValueEnum<'c>) {
        self.scopes
            .borrow_mut()
            .last_mut()
            .unwrap()
            .variables
            .insert(s.to_string(), val);
    }

    /// Gets a variable from the list of scopes.
    fn get_var(&'c self, s: &str) -> AnyValueEnum<'c> {
        self.get_var_opt(s).unwrap()
    }

    /// Gets a variable from the list of scopes.
    fn get_var_opt(&'c self, s: &str) -> Option<AnyValueEnum<'c>> {
        for scope in self.scopes.borrow().iter() {
            if let Some(val) = scope.variables.get(s) {
                return Some(*val);
            }
        }

        None
    }

    fn attribute_for_kind(&'c self, kind: AttributeKind) -> Attribute {
        unsafe { Attribute::new(
            LLVMCreateEnumAttribute(self.context().as_ctx_ref(), kind as u32, 1)
        ) }
    }

    fn attribute_for_type(&'c self, kind: AttributeKind, ty: BasicTypeEnum<'c>) -> Attribute {
        unsafe { Attribute::new(
            LLVMCreateTypeAttribute(self.context().as_ctx_ref(), kind as u32, ty.as_type_ref())
        ) }
    }

    fn builder(&'c self) -> &'c Builder<'c> {
        self.holder.builder()
    }
    fn context(&'c self) -> &'c Context {
        self.holder.context()
    }
    fn module(&'c self) -> &'c Module<'c> {
        self.holder.module()
    }
}

/// Creates a basic type enum from an any type enum.
fn basic_type(an: AnyTypeEnum) -> BasicTypeEnum {
    BasicTypeEnum::try_from(an).unwrap()
}

/// Creates a basic value enum from an any value enum.
fn basic_value(an: AnyValueEnum) -> BasicValueEnum {
    BasicValueEnum::try_from(an).unwrap()
}

/// Returns the actual index of a field within a struct
/// accounting for padding and alignment.
fn index_aligned<'a>(iter: impl Iterator<Item = &'a (HIRType, bool)>, index: u32) -> u32 {
    let mut i = 0;
    for (actual_idx, (_, is_alignment)) in iter.enumerate() {
        if !*is_alignment {
            if i == index {
                eprintln!("actual {actual_idx} -- took {i}");
                return actual_idx as u32;
            }
            i += 1;
        }
    }

    unreachable!("INVALID ALIGNED INDEX! Index: {index}, NumElements: {i}");
}

/// Struct returned by the `emmit_pattern` function.
/// 
/// Contains the basic block to go to if pattern was
/// matched and the one to go if it wasn't matched.
pub struct EmmittedPattern<'c> {
    /// Where you want to go if the pattern was
    /// matched.
    matched: BasicBlock<'c>,
    /// Where you want to go if the pattern wasn't
    /// matched.
    unmatched: Option<BasicBlock<'c>>,
}

/// Options to apply during the optimization of the
/// program.
pub struct OptimizationOptions {
    /// Uses C standart library functions 
    pub c_intrinsic_optimization: bool,
}

impl Default for OptimizationOptions {
    fn default() -> Self {
        Self {
            c_intrinsic_optimization: true,
        }
    }
}
